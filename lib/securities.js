// Generated by CoffeeScript 1.10.0

/* 智能化的投資品種,
  根據行情結構,應對最新行情作出相應操作
  將逐步演化完善
  以下代碼等名目,僅僅是用於對接現有的Python接口,將來系統中都可以統一換成中文
 */
var Securities, Security, util,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

util = require('util');

Security = (function() {
  function Security(master, 代碼1, 名稱1, 策略, 百分比) {
    this.代碼 = 代碼1;
    this.名稱 = 名稱1;
    this.策略 = 策略;
    this.百分比 = 百分比 != null ? 百分比 : 0.618;
    this.初始 = bind(this.初始, this);

    /* 經過如下處理,@對策 function中的this即此證券品種
     */
    this.就緒 = false;
    this.對策 = this.策略.對策;
  }

  Security.prototype.初始 = function(master, 回執) {
    return this.策略.定制(master, this, (function(_this) {
      return function(err, done) {
        if (err == null) {
          _this.就緒 = done;
          return 回執(err, done);
        }
      };
    })(this));
  };

  Security.prototype.應對 = function(最新, 回執) {
    return this.對策(最新, 回執);
  };

  Security.prototype.clearIntervals = function() {
    var each, i, len, ref, results;
    ref = this.intervals;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      each = ref[i];
      results.push(clearInterval(each));
    }
    return results;
  };

  Security.prototype.toString = function() {
    return "a Security 代碼: " + this.代碼;
  };

  return Security;

})();


/* 目標證券群
  此處控制系統中同一個策略每一品種僅需一個object

  根據外部所提供行情,以及預定策略,實時決策操作
 */


/*
  @symbols: ['135333','xxdge']
 */

Securities = (function() {
  function Securities(symbols1, 策略) {
    this.symbols = symbols1;
    this.策略 = 策略;
    this.清潔 = false;
    this.position = null;
    this.品種 = {};
  }


  /** 若@清潔 則選擇可觀察或持倉品種,忽略其他
  *
   */

  Securities.prototype.生成載入 = function(代碼, 名稱, 回執) {

    /** 先生成,不需要再刪除
    *
     */
    var 證券;
    證券 = new Security(this, 代碼, 名稱, this.策略);
    this.品種[代碼] = 證券;
    return 證券.初始(this, (function(_this) {
      return function(err, done) {

        /** 初始設置需要一些時間,tick有可能已經過時了,故沒有操作指令
          在其他地方使用本法時,不必回執
        *
         */
        if (回執 != null) {
          回執(null);
        }
        if (err == null) {
          if (done) {
            if (_this.清潔) {

              /** 過濾層一. 可觀察的超跌低位品種不管他,留下來
              *
               */
              if (!證券.可觀察) {
                if (證券.就緒) {
                  return _this.忽略(代碼);
                }
              }
            }
          }
        }
      };
    })(this));
  };


  /* 從券商賬戶讀取的持倉品種,必須繼續跟蹤,以便止盈止損
   */

  Securities.prototype.持倉品種 = function(symbols) {

    /* @position存在,
      表明已經匯集了持倉品種,可以執行後續分析
     */
    var i, len, symbol;
    if (this.position == null) {
      this.position = [];
    }
    if (symbols != null) {
      for (i = 0, len = symbols.length; i < len; i++) {
        symbol = symbols[i];
        if (indexOf.call(this.position, symbol) < 0) {
          this.position.push(symbol);
        }
      }
    }
    return this.更新品種(symbols);
  };

  Securities.prototype.更新品種 = function(symbols) {
    var i, len, results, symbol;
    if (symbols != null) {
      results = [];
      for (i = 0, len = symbols.length; i < len; i++) {
        symbol = symbols[i];
        if (indexOf.call(this.symbols, symbol) < 0) {

          /* 須檢測 symbol 是否正常?
          
            先加入,發現不需要再去掉
           */
          results.push(this.symbols.push(symbol));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  Securities.prototype.忽略 = function(symbol) {

    /** 過濾層一. 可觀察的超跌低位品種不管他,留下來
    *
     */
    if (this.position != null) {

      /** 過濾層二. 持倉的品種,即使非可觀察低位品種,也必須留下來,作止盈止損監控
        其他的,當天都不必跟蹤了
      *
       */
      if (indexOf.call(this.position, symbol) < 0) {
        this.品種[symbol].clearIntervals();
        delete this.品種[symbol];
        this.symbols.splice(this.symbols.indexOf(symbol), 1);
        return util.log("securities >> 監控範圍" + this.symbols.length + "個品種: " + this.symbols);
      }
    }
  };

  Securities.prototype.應對組合即時行情 = function(jso, 回執) {
    var code, results, symbol, tick;
    results = [];
    for (code in jso) {
      tick = jso[code];
      symbol = tick.代碼;
      if (indexOf.call(this.symbols, symbol) >= 0) {
        if (this.品種[symbol] != null) {

          /**
          @品種[symbol].應對(tick, 回執)
          
          如此一來,證券未就緒則不對即時行情作任何反應,會有風險?
          *
           */
          if (this.品種[symbol].就緒) {
            results.push(this.品種[symbol].應對(tick, 回執));
          } else {
            results.push(回執(null));
          }
        } else {
          results.push(this.生成載入(tick.代碼, tick.名稱, 回執));
        }
      } else {
        util.log('securities.coffee>> 應對 新出現 tick.代碼:', symbol);
        if (symbol !== 'sz') {
          this.symbols.push(symbol);
          results.push(this.生成載入(tick.代碼, tick.名稱, 回執));
        } else {
          results.push(void 0);
        }
      }
    }
    return results;
  };

  Securities.prototype.clearIntervals = function() {
    var each, i, len, ref, results;
    util.log('securities>> clearIntervals');
    ref = this.symbols;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      each = ref[i];
      results.push(this.品種[each].clearIntervals());
    }
    return results;
  };

  return Securities;

})();

module.exports = Securities;

//# sourceMappingURL=securities.js.map
