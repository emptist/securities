// Generated by CoffeeScript 1.10.0
var Securities, Security, hists, 分鐘, 小時, 池, 秒,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

hists = require('sedata').hists;

池 = require('seyy').池;


/* 智能化的投資品種,
  根據行情結構,應對最新行情作出相應操作
  將逐步演化完善
  以下代碼等名目,僅僅是用於對接現有的Python接口,將來系統中都可以統一換成中文
 */

秒 = 1000;

分鐘 = 60 * 秒;

小時 = 60 * 分鐘;

Security = (function() {
  function Security(代碼, 策略, 百分比) {
    this.代碼 = 代碼;
    this.策略 = 策略;
    this.百分比 = 百分比 != null ? 百分比 : 0.0618;
    if (this.代碼.length < 6) {
      console.error(this.代碼 + " 代碼不對");
    }

    /* 經過如下處理,@對策 function中的this即此證券品種
     */
    this.對策 = this.策略.對策;

    /* 在此取得行情,準備好天地線和頂底指標,
      也可在 observer中做.好處是此處不用再改寫.
      每隔 n分鐘更新一次 n分鐘數據
     */
    hists({
      symbol: this.代碼,
      type: 'm05'
    }, (function(_this) {
      return function(err, arr) {
        var pool, updateM05;
        if (!err) {
          if (arr == null) {

            /* 用週線確定所需的行情片段再獲取日線,以免數據太大
             * 每隔24小時,在閉市期間更新一次日線數據
             *
            排查發現個別品種下載數據會出錯
             */
            console.log(_this.代碼 + " 5分鐘數據下載不到");
          }
          if ((arr != null ? arr.length : void 0) > 0) {
            pool = new 池();
            _this.五分鐘線池 = pool.序列(arr);
            updateM05 = function() {
              return hists({
                symbol: this.代碼,
                type: 'm05',
                len: 1
              }, function(err, arr) {
                if (!err) {
                  if (arr[0].day !== this.五分鐘線池.燭線.slice(-1)[0].day) {
                    return this.五分鐘池.新增(arr[0]);
                  }
                }
              });
            };
            return _this.iM05 = setInterval(updateM05, 5 * 分鐘);
          }
        }

        /* TODO:
          出錯時換一個數據源再嘗試
         */
      };
    })(this));
    hists({
      symbol: this.代碼,
      type: 'week',
      len: 1000
    }, (function(_this) {
      return function(err, arr) {
        var len, pool;
        if (err != null) {
          console.error(err);
        }
        if (arr == null) {

          /* 用週線確定所需的行情片段再獲取日線,以免數據太大
           * 每隔24小時,在閉市期間更新一次日線數據
           *
          排查發現個別品種下載數據會出錯
           */
          console.log(_this.代碼 + " 週線下載不到");
        }
        if ((arr != null ? arr.length : void 0) > 0) {
          pool = new 池();
          _this.週線池 = pool.序列(arr);

          /* TODO:
            出錯時換一個數據源再嘗試
           */
          len = _this.週線池.求主魚長() * 5;
          return hists({
            symbol: _this.代碼,
            type: 'day',
            len: len
          }, function(err, arr) {
            if (err) {
              return console.error(_this.代碼, err);
            } else {
              pool = new 池();
              return _this.日線池 = pool.序列(arr);
            }

            /* TODO:
              出錯時換一個數據源再嘗試
             */
          });
        }
      };
    })(this));
  }

  Security.prototype.clearIntervalM05 = function() {
    return clearInterval(this.iM05);
  };

  Security.prototype.clearIntervalDay = function() {
    return clearInterval(this.iDay);
  };

  Security.prototype.clearIntervalWeek = function() {
    return clearInterval(this.iWeek);
  };

  Security.prototype.clearIntervals = function() {
    this.clearIntervalM05();
    this.clearIntervalDay();
    return this.clearIntervalWeek();
  };

  Security.prototype.toString = function() {
    return "a Security 代碼: " + this.代碼;
  };


  /*合適: (回應)->
    @代碼? and 回應 this
  止損: (最新, 回應)->
    @對策(最新, 回應)
  #為何不行? 應對: @止損
   */

  Security.prototype.應對 = function(最新, 回應) {
    return this.對策(最新, 回應);
  };

  return Security;

})();


/* 目標證券群
  此處控制系統中同一個策略每一品種僅需一個object

  根據外部所提供行情,以及預定策略,實時決策操作
 */


/*
  @codes: ['135333','xxdge']
 */

Securities = (function() {
  function Securities(codes1, 策略) {
    var code, i, len1, ref;
    this.codes = codes1;
    this.策略 = 策略;
    console.log('初始代碼表:', this.codes);
    this.品種 = {};
    ref = this.codes;
    for (i = 0, len1 = ref.length; i < len1; i++) {
      code = ref[i];
      this.品種[code] = new Security(code, this.策略, 0.618);
    }
  }

  Securities.prototype.更新品種 = function(codes) {
    var code, i, len1, results;
    results = [];
    for (i = 0, len1 = codes.length; i < len1; i++) {
      code = codes[i];
      if (indexOf.call(this.codes, code) < 0) {
        this.codes.push(code);
        results.push(this.品種[code] = new Security(code, this.策略, 0.618));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Securities.prototype.應對 = function(jso, 回應) {
    var code, k, results, tick;
    results = [];
    for (k in jso) {
      tick = jso[k];
      code = tick.代碼;
      console.log('securities 應對>tick.代碼:', code);
      if (indexOf.call(this.codes, code) < 0) {
        this.codes.push(code);
        this.品種[code] = new Security(code, this.策略, 0.618);
      }
      results.push(this.品種[code].應對(tick, 回應));
    }
    return results;
  };

  Securities.prototype.clearIntervals = function() {
    var each, i, len1, ref, results;
    ref = this.品種;
    results = [];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      each = ref[i];
      results.push(each.clearIntervals());
    }
    return results;
  };

  return Securities;

})();

module.exports = Securities;

//# sourceMappingURL=securities.js.map
